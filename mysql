
# 一.初识MySQL

## 为什么学习数据库

岗位的需求

现在的世界是大数据时代

被迫需求:存数据



## 什么是数据库

数据库(DB,DataBase)

概念:数据仓库,软件,安装在操作系统(windows,linux,mac)之上!	SQL,可以存储大量的数据

作用:存储数据,管理数据



## 数据库分类

**关系数据库**:	(SQL)

- MySQL,Oracle,Sql server,DB2,SQLlite
- 通过表和表之间,行和列之间的关系进行数据的存储,例如学员信息表,考勤表



**非关系型数据库:**	(NoSQL)Not Only

- Redis,MongDB

- 非关系型数据库,对象存储,通过对象的自身的属性来决定



**DBMS(数据库管理系统)**

- 数据库的管理软件,科学有效的管理我们的数据.维护和获取数据.
- MySQL,数据库管理系统



## 数据库简介

MySQL是一个**关系型数据库管理系统**

MySQL是最好的RDBMS	(Relational Database Management System,	关系数据库管理系统)	应用软件之一

开源的数据库软件,体积小,速度快,成本低,所以必须会~



## 安装MySQL

安装建议:

尽量不要使用exe,因为会进入注册表

尽可能使用压缩包安装~



1.解压到自己想要存放的位置

2.添加环境变量

3.新建MySQL配置文件ini

```[mysqld] 
port=3306
basedir=E:\MYSQL\mysql-8.0.21-winx64\bin
datadir=E:\MYSQL\mysql-8.0.21-winx64\data
max_connections=20
max_connect_errors=1000 
character-set-server=utf8
default-storage-engine=INNODB
default_authentication_plugin=mysql_native_password
[mysql]
default-character-set=utf8
[client]
port=3306
default-character-set=utf8
```

4.启动管理员模式下的CMD,并将路径切换至mysql下的bin目录,然后输出mysqld -install(安装mysql)

5.再输入mysql --initialize-insecure --user=mysql	初始化数据文件

6.启动mysql修改密码



## 数据库操作(基本命令)

所有的语句都使用 ; 结尾

```sql
show databases; -- 查看所有的数据库
use school; -- 切换数据库
show tables; -- 查看当前数据库中所有的表
show create database school; -- 查看创建数据库的语句
show create table student; -- 查看创建表的定义语句
describe student; -- 查看指定表中的所有信息
update mysql.user set authentication_string=password('root')where user='root' and host='localhost'; -- 修改密码
flush privileges; -- 刷新权限
create database city; -- 创建一个数据库
exit; -- 退出连接
EXPLAIN SELECT * FROM app_user WHERE NAME = '用户999999' --EXPLAIN 分析sql执行的状况
```

 

# 二.数据库操作

操作数据库 > 操作数据库中的表 > 操作数据库中表的数据

增删改查数据库(create,drop,update,select)

## 关于数据库引擎

|              | MYISAM(早些年使用) | INNODB(默认使用)                   |
| :----------- | :----------------- | :--------------------------------- |
| 常规操作     | 节约空间,速度较快  | 安全性高,事务的处理,多表多用户操作 |
| 事务的支持   | 不支持             | 支持                               |
| 数据行锁定   | 不支持             | 支持                               |
| 外键约束     | 不支持             | 支持                               |
| 全文索引     | 支持               | 支持                               |
| 表空间的大小 | 较小               | 较大,约为MYISAM的2倍               |



## 修改表

> - 修改表student名为student1
>
>   ```sql
>    ALTER TABLE student RENAME AS student1	
>   ```

> - 给表添加字段age
>
>   ```sql
>    ALTER TABLE student1 ADD age INT(11)
>   ```

> - 给表中的age修改数据类型(modify用来修改字段类型和约束,不能字段重命名)
>
>   ```sql
>    ALTER TABLE student1 MODIFY age VARCHAR(1)
>   ```

> - 给表中的属性age修改为属性age1(change用来字段重命名,不能修改字段类型和约束)
>
>   ```sql
>    ALTER TABLE student1 CHANGE age age1 INT(1)	
>   ```

## 删除表

>- 删除表中的字段age1
>
> ```sql
>ALTER TABLE student1 DROP age1
> ```

>- 删除表
>
> ```sql
>DROP TABLE IF EXISTS teacher
> ```



# 三.MySQL数据管理

## 外键(了解)

第一种方式:在写命令时添加外键

```sql
CREATE TABLE `grade`(`gradeid` INT(10) NOT NULL PRIMARY KEY auto_increment COMMENT '年纪id',`gradename` VARCHAR(50) NOT NULL COMMENT '年纪名称')-- 学生表的gradeid字段 要去引用年级表的gradeid-- 定义外键key-- grade是父表,student是子表-- CONSTRAINT:给这个外键添加约束(执行引用) references 引用CREATE TABLE `student` (  `id` int NOT NULL AUTO_INCREMENT COMMENT '学号',  `name` varchar(30) NOT NULL DEFAULT '匿名' COMMENT '姓名',  `pwd` varchar(20) NOT NULL DEFAULT '123456' COMMENT '密码',  `sex` varchar(2) NOT NULL DEFAULT '女' COMMENT '性别',  `birthday` timestamp NULL DEFAULT NULL COMMENT '出生日期',	`gradeid` INT(10) NOT NULL COMMENT '学生的年纪',  `address` varchar(100) DEFAULT NULL COMMENT '家庭地址',  `email` varchar(50) DEFAULT NULL COMMENT '邮箱',  PRIMARY KEY (`id`),	KEY `FK_gradeid` (`gradeid`),	CONSTRAINT `FK_gradeid` FOREIGN KEY (`gradeid`) REFERENCES `grade` (`gradeid`)) ENGINE=InnoDB DEFAULT CHARSET=utf8-- 创建表的时候没有添加关键ALTER TABLE `student`ADD CONSTRAINT `FK_gradeid` FOREIGN KEY (`gradeid`) REFERENCES `grade` (`gradeid`);
```

第二种方式:操作简单,可以不用在写命令时添加外键

使用navicat操作

>1. 在表student中设置外键,就需要打开student设计表
>2. 对话框点击`设置外键`
>
>| 名       | 字段           | 被引用的模式     | 被引用的表(父) | 被引用的字段   | 删除时                    | 更新时                          |
>| -------- | -------------- | ---------------- | -------------- | -------------- | ------------------------- | ------------------------------- |
>|          | gradeid        | school           | grade          | gradeid        | SET NULL                  | CASCADE                         |
>| 可以为空 | 要设置的外键名 | 外键关联的数据库 | 关联的表       | 关联外表的字段 | 当关联表删除后,字段设为空 | 关联的表更新后,外键字段自动更新 |
>
>

**删除有外键关系的表时,必须要先删除引用别人的表,再删除被引用的表(主表)**



## DML语言(重点)

### 数据操作语言

#### 添加-->insert

>- 默认语句:	INSERT INTO 表名([字段名1,字段名2,字段名3])values('值1','值2','值3')
>
> ```sql
>INSERT INTO  `grade` (`gradename`) VALUES ('大四')
> ```

>- 插入多个字段
>
> ```sql
>INSERT INTO `grade`(`gradename`) VALUES ('大一'),('大二'),('大三')
> ```

>- 多个列插入数据
>
> ```sql
>INSERT INTO `student`(`name`,`pwd`,`sex`) VALUES ('张三' , 'aaa' , '男')
> ```

>- 省略字段,但是后面的值必须要一一对应
>
> ```sql
>INSERT INTO `student`VALUES ('2' , '5' , 李四' , '男' , '2000-01-01' , 1 , '西安' , 'email')
> ```



#### 修改-->update

>- update `表名`  set  colnum_name= `新值` where `条件`
>
> ```sql
>UPDATE `student` SET `name` = '狂神' WHERE id = 1;
> ```

>- update `表名`  set  colnum_name= `新值` where `条件[between and] `——**还有 `or` , `and` 操作符**
>
> ```sql
>UPDATE `student` SET `name` = '李四'  WHERE id BETWEEN 1 AND 3;
> ```

>- 不指定where条件的情况下,会改动表内所有数据
>
> ```sql
>UPDATE `student` SET `name` = '长江七号'
> ```

>- 修改多个属性,使用逗号隔开
>
> ```sql
>UPDATE `student` SET `name` = '狂神' , `email`='24736743@qq.com' WHERE id = 1;
> ```



#### 删除-->delete	truncate

>- 删除数据**(不建议使用)**
>
> ```sql
>DELETE FROM student 
> ```

>- delete from 表名 where `条件`
>
> ```sql
>DELETE FROM student WHERE id = 1
> ```

>- truncate 清空
>
> ```sql
>TRUNCATE student
> ```

##### delete和Truncate的区别

- 相同:都能删除数据,都不会删除表结构
- 不同:
  - delete:自增列不会清零
  - TRUNCATE:自增列,计数器会归零
  - TRUNCATE:不会影响事务



# DQL查询数据(最重点)

## DQL:(Data Query LANGUAGE 数据查询)

>- Select完整的语法
>
> ```sql
>SELECT [DISTINCT] [*] from [tablename1] -- 查询 [去重] 需要查询的字段 from 表inner/left/right join tablename2 -- xxx join 要连接的表 on tablename1.* = table2.* -- on 等值判断[WHERE ......] -- 指定结果需满足的条件[Group BY ...] -- 指定结果按照哪几个字段来分组[HAVING ...] -- 聚合函数不能与where同时使用,但是having可以[ORDER BY ...] -- 通过哪个字段排序[升序ACS/降序DECS][LIMIT...] -- 分页
> ```

- ==数据库中最核心的语言,最重要的语句==
- 使用频率最高的语句

>- 查询学生表中全部数据
>
> ```sql
>SELECT * FROM student
> ```

>- 查询指定字段 
>
> ```sql
>SELECT StudentNo,studentName from student
> ```

>- 起别名,给字段和表起一个名字 AS
>
> ```sql
>SELECT StudentNo AS 学号,studentName AS 学生姓名 from student AS 学生表
> ```

>- 字符串拼接 函数 Concat(a,b)
>
> ```mysql
>SELECT CONCAT('姓名',StudentName) AS 新名字 FROM student
> ```

>- 去重distinct,查询所有学生的成绩并去重
>
> ```sql
>SELECT DISTINCT studentno from result
> ```

>- 查询当前系统版本(函数)
>
> ```sql
>SELECT VERSION()
> ```

>- 用来计算(表达式)
>
> ```sql
>SELECT 1213+12*231 AS 结果
> ```

>- 学员考试成绩+1分
>
> ```sql
>SELECT studentno,studentresult +1 AS '分值' FROM result
> ```



## where条件子句

作用:检索数据中 符合条件的值

>逻辑运算符 and	or	not

>- 查询考试成绩在90~100之间的学生
>
> ```sql
>SELECT studentno,studentresult FROM result WHERE studentresult>=90 AND studentresult<=100
> ```
>
>- 查询学号不是1000的学生
>
> ```sql
>SELECT studentno,studentresult from result WHERE studentno != 1000SELECT studentno,studentresult from result WHERE NOT studentno 1000
> ```
>
>- 查询考试成绩小于90或大于100的学生
>
> ```sql
>SELECT studentno,studentresult FROM result WHERE studentresult<=90 OR studentresult>=100
> ```
>
>

## IN查询

>- 查询1001,1002,1003号的学员
>
> ```sql
>SELECT studentno,studentname FROM student WHERE studentno IN(1001,1002,1003)
> ```

>- 查询在北京,深圳的学生
>
> ```sql
>SELECT studentno,studentname FROM student WHERE address IN('北京','深圳')
> ```
>
>



## 模糊查询

**%**(代表任意个字符)			**_**(代表一个字符)

>- 查询姓刘的同学
>
> ```sql
>SELECT studentno,studentname FROM student WHERE studentname LIKE '刘%'
> ```

>- 查询姓刘的同学,姓氏后面只有一个字的
>
> ```sql
>SELECT studentno,studentname FROM student	WHERE studentname LIKE '刘_'
> ```

>- 查询名字中间有`强`字的同学
>
> ```sql
>SELECT studentno,studentname FROM student where studentname LIKE '%强%'
> ```



## 联表查询

### join操作

公式:`select`  要查询的数据 `from` 表 `LEFT/RIGHT/INNER` `Join` 连接的表 `ON` 交叉条件

多表查询:先查询两张表,再慢慢增加

JOIN的七种方式

<img src="E:\Typora\Typora图片\image-20210416151422386.png" alt="image-20210416151422386" style="zoom:80%;" />

>- 查询参加了考试同学的学号,姓名,科目编号,分数(`INNER JOIN`)
>
> ```sql
>SELECT s.studentno,studentname,subjectNO,studentresultFROM student sINNER JOIN result rWHERE s.studentno = r.studentno
> ```

>- 查询参加了考试同学的学号,姓名,科目编号,分数(`RIGHT JOIN ON`)
>
> ```sql
>SELECT s.studentno,studentname,subjectNO,studentresultFROM student sRIGHT JOIN result rON s.studentno = r.studentno
> ```

>- 查询参加了考试同学的学号,姓名,科目编号,分数(`LEFT JOIN ON`)
>
> ```sql
>SELECT s.studentno,studentname,subjectNO,studentresultFROM student sLEFT JOIN result rON s.studentno = r.studentno
> ```

>- 查询缺考的同学(`LEFT JOIN ON WHERE `)
>
> ```sql
>SELECT s.studentno,studentname,subjectNO,studentresultFROM student sLEFT JOIN result rON s.studentno = r.studentnoWHERE studentresult IS NULL
> ```

>- 查询参加了考试同学的学号,学生姓名,科目名,分数(`RIGHT JOIN ON INNER JOIN ON`)
>
> ```sql
>SELECT s.studentno,studentname,subjectname,studentresultFROM student sRIGHT JOIN result rON s.studentno = r.studentnoINNER JOIN subject subON r.subjectno = sub.subjectno
> ```

| 操作       | 描述                                         |
| ---------- | -------------------------------------------- |
| INNER JOIN | 如果表中至少有一个匹配,就返回true,相当于交集 |
| LEFT JOIN  | 即使右表中没有匹配,也会从左表中返回所有的值  |
| RIGHT JOIN | 即使左表中没有匹配,也会从右表中返回所有的值  |



### 自连接(了解)

自己的表和自己的表连接,**核心:一张表拆为两张一样的表即可**

<img src="E:\Typora\Typora图片\image-20210416161450590.png" alt="image-20210416161450590" style="zoom:80%;" />

父类:

| catgoryid | catgoryName |
| --------- | ----------- |
| 2         | 信息技术    |
| 3         | 软件开发    |
| 5         | 美术设计    |
|           |             |

子类:

| pid  | catgoryid | catgoryName |
| ---- | --------- | ----------- |
| 3    | 4         | 数据库      |
| 2    | 8         | 办公信息    |
| 3    | 6         | web开发     |
| 5    | 7         | PS技术      |

操作:查询父类对应的子类关系

| 父类     | 子类     |
| -------- | -------- |
| 信息技术 | 办公信息 |
| 软件开发 | 数据库   |
| 软件开发 | web开发  |
| 美术设计 | PS技术   |

>- 查询父子信息:把一张表看为两个一模一样的表
>
> ```sql
>SELECT a.categoryName '父栏',b.categoryName '子栏'FROM category a,category bWHERE a.categoryid = b.pid
> ```

<img src="E:\Typora\Typora图片\image-20210416163512078.png" alt="image-20210416163512078" style="zoom:80%;" />



## 分页和排序

### 升序ASC

>```sql
>SELECT s.studentno,studentname,subjectname,studentresultFROM student sINNER JOIN result rON s.studentno = r.studentnoINNER JOIN `subject` subON r.subjectno = sub.subjectnoORDER BY studentresult ASC -- ORDER BY:通过哪个字段排序,怎么排
>```



### 降序DESC

>```sql
>SELECT s.studentno,studentname,subjectname,studentresultFROM student sINNER JOIN result rON s.studentno = r.studentnoINNER JOIN `subject` subON r.subjectno = sub.subjectnoORDER BY studentresult DESC -- ORDER BY:通过哪个字段排序,怎么排
>```



### 分页

- 第一页 limit 0,5		(1-1) * 5
- 第二页 limit 5,5		(2-1) * 5
- 第三页 limit 10,5	 (3-1) * 5
- 第N页 limit        		(n-1) * pageSize,pageSize
- `n:当前页`
- `(n-1) * pageSize:起始值`
- `pageSize:页面大小`
- `数据总额/页面大小 =总页数 `

>```sql
>SELECT s.studentno,studentname,subjectname,studentresultFROM student sINNER JOIN result rON s.studentno = r.studentnoINNER JOIN `subject` subON r.subjectno = sub.subjectnoORDER BY studentresult ASCLIMIT 2		-- 查询前两个
>```

>```sql
>SELECT s.studentno,studentname,subjectname,studentresultFROM student sINNER JOIN result rON s.studentno = r.studentnoINNER JOIN `subject` subON r.subjectno = sub.subjectnoORDER BY studentresult ASCLIMIT 1,2	-- 从第一个数开始(不算第一个),查询前两个
>```



## 子查询

本质:在where语句中嵌套一个查询语句

>查询 科目:`数据库结构-1` 的所有考试结果(学号,科目编号,成绩),降序排列
>
>```sql
>SELECT studentno,subjectno,studentresultFROM resultWHERE subjectno = (SELECT subjectno FROM subject WHERE subjectname = '数据库结构-1')ORDER BY studentresult DESC
>```

>查询课程为`高等数学-2` 且分数不小于80 的同学的学号和姓名
>
>```sql
>SELECT s.studentno ,studentnameFROM student sINNER JOIN result rON s.studentno = r.studentnoWHERE studentresult >=80 AND subjectno = (SELECT subjectno FROM `subject`WHERE subjectname = '高等数学-2')
>```

## 分组groupby

>- 聚合函数不能与where同时使用,having可以
>
> ```sql
>SELECT subjectname,AVG(studentresult),MAX(studentresult),MIN(studentresult)FROM result rINNER JOIN `subject` subON r.subjectno = sub.subjectnoGROUP BY r.subjectno -- 通过科目编号来分组HAVING AVG(studentresult)>=80
> ```
>
>
>
>



# MySQL函数

## 常用函数

>```sql
>SELECT ABS(-8) -- 绝对值SELECT CEILING(9.1) -- 向上取整SELECT FLOOR(9.9) -- 向下取整SELECT RAND() -- 0~1之间的随机数SELECT SIGN(10) -- 判断一个数的符号,负数返回-1,正数返回1,0返回0SELECT CHAR_LENGTH('你好我的名字是lyn') -- 字符串长度SELECT CONCAT('我','爱','你们') -- 拼接字符串SELECT INSERT('我爱学习mysql',1,2,'超级热爱') -- 从索引为1的地方开始,SELECT REPLACE(studentname,'张','卢')FROM student WHERE studentname LIKE '张%' -- REPLACE替换SELECT NOW() -- 获取当前日期SELECT VERSION() -- 获取mysql版本
>```

## 聚合函数

>- count计数
>
> ```sql
>SELECT COUNT(studentname) FROM student -- COUNT(studentname)会忽略所有的null值SELECT COUNT(*) FROM student -- COUNT(*)不会忽略null值
> ```
>
>- sum总和   avg平均值   max最大值   min最小值
>
> ```sql
>SELECT SUM(studetnresult),AVG(studentresult),MAX(studentresult),MIN(studentresult)FROM result r
> ```

## 数据库级别的MD5加密(扩展)

什么是MD5?

主要增强算法复杂度和不可逆性

>- 指定某一个列加密
>
> ```sql
>UPDATE testmd5 SET pwd=MD5(pwd)WHERE id=1
> ```

>- 加密全部的列
>
> ```sql
>UPDATE testmd5 SET pwd=MD5(pwd)
> ```

>- 插入的时候加密
>
> ```sql
>INSERT INTO testmd5 VALUES(4,'xiaoming',MD5(123456))
> ```

>- 如何校验:将用户传递进来的密码,进行md5加密,然后比对加密后的值
>
> ```sql
>SELECT * FROM testmd5 WHERE `name` = 'xiaoming' AND pwd=MD5('123456')
> ```



# 事务

## 事务的原则ACID

参考博客链接:https://blog.csdn.net/dengjili/article/details/82468576



### `原子性`:

> - **一个事务要么全部提交成功,要么全部失败回滚,不能只执行其中一部分操作**
>
>   例如:A给B转100元,A转完后B没有收到,此时事务回滚,A和B的钱不变



### `一致性`:

> - **指在事务开始之前和事务结束之后,数据库的完整性约束没有被破坏,就是数据保持一致**
>
>   例如:A有1000元,B有200元,A给B转账.不管事务成功还是失败,钱的总数都是1200
>
> - 保障事务的一致性,可以从两个层面入手
>
>   - 数据库机制层面
>
>     设置约束(唯一约束,外键约束,Check约束等)和触发器设置
>
>   - 业务层面
>
>     一致性是保持业务的一致性,需要由开发人员进行保证,或者通过转移到数据库机制层面进行保证



### `隔离性`:

>- 多个事务并发访问时,事务之间是隔离的,事物之间不会相互影响
>
> 例如:在Windows中,多个进程是无法对同一个文件进行修改的
>
> <img src="E:\Typora\Typora图片\image-20210420192747695.png" alt="image-20210420192747695" style="zoom:80%;" />
>
>

#### 事务的隔离级别

`脏读`:指一个事务读取了另外一个事务未提交的数据

`幻读`:指在一个事务内读取到了别的事务插入的数据,导致前后数据读取不一致(一般是行影响,多了一行)

`不可重复读`:在一个事务内读取表中的某一行数据,多次读取结果不同(不一定是错误的,只是某些场合不对)

​		例如: 页面统计,点击生成报表的时候,突然有人转账进来了100,导致前后数据不同

`丢失更新`:两个事务同时读取同一条记录,A先修改记录,B也修改记录(B不知道A修改过),B提交的数据覆盖了A的修改的数据



### `持久性`:

一旦事务提交,那么它对数据库中的对应数据的状态的变更就会永久保存到数据库中.即使发生系统崩溃或

机器宕机等故障,只要数据库能够重新启动,那么一定能够将其恢复到事务成功结束的状态



## 执行事务

### 执行流程

<img src="E:\Typora\Typora图片\image-20210420204402007.png" alt="image-20210420204402007" style="zoom:80%;" />

```sql
--mysql是默认开启事务自动提交的SET autocommit = 0 -- 关闭事务SET autocommit = 1 -- 开启(默认)事务-- 手动处理事务SET autocommit = 0 -- 关闭自动提交-- 事务开启START TRANSACTION -- 标记一个事务的开始,从这个之后的sql都在同一个事务内COMMIT -- 提交:持久化(成功就提交)ROLLBACK -- 回滚:回到原来的样子(失败就回滚) -- 事务结束SET autocommit = 1 -- 开启自动提交SAVEPOINT `保存点名`-- 设置一个事务的保存点,相当于游戏的存档ROLLBACK TO SAVEPOINT `保存点名` -- 回滚到保存点RELEASE SAVEPOINT `保存点名` -- 撤销保存点
```

### 模拟场景

```sql
CREATE DATABASE shop -- 创建shop数据库use shop -- 使用shop数据库CREATE TABLE `account`(`id` INT(3) NOT NULL,`name` VARCHAR(30) NOT NULL,`money` DECIMAL(9,2)NOT NULL, -- DECIMAL(9,2)代表一个九位数,其中小位数是两位PRIMARY KEY (`id`))INSERT INTO account(`name`,`money`)VALUES('A',2000.00),('B',10000.00)-- 模拟转账SET autocommit=0 -- 关闭自动提交START TRANSACTION -- 开启一个事务UPDATE account SET money=money-500 WHERE `name` = 'A' -- A减500UPDATE account SET money=money+500 WHERE `name` = 'B' -- B加500COMMIT -- 提交事务(就被持久化了!)SET autocommit=1 -- 开启自动提交
```



# 索引

> 索引(index)是帮助MySQL高效获取数据的数据结构.
>
> 提取句子主干,就可以得到索引的本质:索引是数据结构

## 索引的分类

- 主键索引 (PRIMARY KEY)
  - 唯一的标识,主键不可重复,只有有一个列作为主键
- 唯一索引 (UNIQUE KEY)
  - 避免重复的列出现,唯一索引可以重复,多个列都可以标识为 唯一索引
- 常规索引 (KEY/INDEX)
  - 默认的,index,key关键字来设置
- 全文索引 (FullText)
  - 在特定的数据库引擎下才有MyISAM
  - 快速定位数据



基础语法

```sql
-- 索引的使用-- 1.在创建表的时候给字段增加索引-- 2.创建完毕后,增加索引-- 显示所有的索引信息SHOW INDEX FROM student-- 增加一个全文索引 (索引名) 列名ALTER TABLE student ADD FULLTEXT INDEX studentname(studentname)-- EXPLAIN 分析sql执行的状况EXPLAIN SELECT * FROM student -- 非全文索引EXPLAIN SELECT * FROM student WHERE MATCH(studentname)against('刘')
```



## 测试索引

```sql
-- 创建app_user表CREATE TABLE `app_user` (`id` BIGINT(20) UNSIGNED NOT NULL AUTO_INCREMENT,`name` VARCHAR(50) DEFAULT'' COMMENT'用户昵称',`email` VARCHAR(50) NOT NULL COMMENT'用户邮箱',`phone` VARCHAR(20) DEFAULT'' COMMENT'手机号',`gender` TINYINT(4) UNSIGNED DEFAULT '0'COMMENT '性别（0：男;1:女）',`password` VARCHAR(100) NOT NULL DEFAULT '' COMMENT '密码',`age` TINYINT(4) DEFAULT'0'  COMMENT '年龄',`create_time` DATETIME DEFAULT CURRENT_TIMESTAMP,`update_time` TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,PRIMARY KEY (`id`)) ENGINE=INNODB DEFAULT CHARSET=utf8 COMMENT = 'app用户表'-- 插入100w条数据delimiter $$set global log_bin_trust_function_creators=TRUE;-- 写函数之前必须要写，标志CREATE FUNCTION mock_data()RETURNS INTBEGINDECLARE num INT DEFAULT 1000000;DECLARE i INT DEFAULT 0;WHILE i<num DOINSERT INTO `app_user`(`name`,`email`,`phone`,`gender`)VALUES(CONCAT('用户',i),'19224305@qq.com','123456789',FLOOR(RAND()*2));SET i=i+1;END WHILE;RETURN i;END;SELECT mock_data()$$-- 查询数据 SELECT * FROM app_user WHERE NAME = '用户999999' -- 没加索引的情况下查询时间比较慢，2s左右-- 创建索引CREATE INDEX id_app_user_name ON app_user(`name`);-- CREATE INDEX 索引名 ON 表（字段）-- 查询数据 SELECT * FROM app_user WHERE NAME = '用户999999' -- 创建完索引后查询速度快，0.001s
```



## 索引原则

- 索引不是越多越好，一般加在经常查询的字段上
- 不要对进程变动数据加索引
- 小数据量的表不需要加索引



> 索引的数据结构

显示所有的索引信息：SHOW INDEX FROM student

Hash类型的索引

<img src="E:\Typora\Typora图片\image-20210421205903633.png" alt="image-20210421205903633"  />

Btre：InnoDB的默认数据结构



`涨薪必读!:`[MySQL索引背后的数据结构及算法原理](http://blog.codinglabs.org/articles/theory-of-mysql-index.html)



# 权限管理和备份

## 用户管理

> 可视化管理

<img src="E:\Typora\Typora图片\image-20210422203239041.png" alt="image-20210422203239041" style="zoom:80%;" />

> SQL命令操作

用户表:mysql.user

本质:读这张表的增删改查

```sql
-- 创建用户CREATE USER luyuning IDENTIFIED by '123456'--修改密码(指定用户)ALTER USER 'root'@'localhost' IDENTIFIED by '123456'-- 重命名RENAME USER luyuning TO luyuning2-- 用户授权 ALL PRIVILEGES 全部的权限,库.表GRANT ALL PRIVILEGES ON *.* TO luyuning-- 给luyuning用户表下的所有的库和表设置全部权限-- 查询权限SHOW GRANTS for luyuningSHOW GRANTS FOR root@localhost-- 撤销权限remove哪些权限,在哪个库插销,给谁撤销REMOVE  ALL PRIVILEGES ON *_* FROM luyuning -- 给luyuning撤销所有权限-- 删除用户DROP USER luyuning
```

## 备份

> 导出

为什么要备份?

- 保证重要的数据不丢失
- 数据转移

MySQL数据库备份的方式?

- 直接拷贝物理文件
- 在可视化工具中手动导出
- 使用命令行导出 mysqldump `在cmd窗口使用`
  - ![image-20210423184356191](E:\Typora\Typora图片\image-20210423184356191.png)



>导入(登录的情况下,切换到指定的数据库)

- source备份文件

  source d:/a.sql

- 使用命令行导入

  mysql -u用户名 -p密码 库名< 备份文件



# 三大范式

> 第一范式(1NF)

原子性:保证每一列不可再分

> 第二范式(2NF)

前提:满足第一范式

每张表只描述一件事情

> 第三范式(3NF)

前提:满足第一范式和第二范式

第三范式需要确保数据表中的每一列数据都和主键直接相关,而不能间接相关

> 规范性和性能的问题

关联查询的表不得超过三张表

- 考虑商业化的需求和目标,数据库的性能更加重要
- 在规范性能的问题的时候,需要适当的考虑一下规范性
- 故意给某些表增加一些冗余的字段
- 故意增加一些计算列(从大数据量降低为小数据量的查询:索引)



# JDBC(重要)

## 数据库驱动

应用程序---->MySQL驱动---->数据库

我们的程序会通过数据库驱动,和数据库打交道!

## JDBC

SUN为了简化对数据库统一的操作,提供了一个规范操作,叫作JDBC

这些规范的实现由具体的厂商去做

对于开发人员来说,只需要掌握JDBC接口的操作即可

<img src="E:\Typora\Typora图片\image-20210424192737754.png" alt="image-20210424192737754" style="zoom:80%;" />

## 第一个JDBC程序

>创建测试数据库

1.创建一个普通项目

2.导入数据库驱动(创建一个lib文件夹,里面放入mysql-connector-java的jar包,然后Add as Library)

3.编码测试

```java
package Demo14.JDBC;import java.sql.*;//第一个JDBC程序public class jdbcFirstDemo {    public static void main(String[] args) throws ClassNotFoundException, SQLException {        //1.加载驱动        Class.forName("com.mysql.cj.jdbc.Driver");//固定写法        //2.用户信息和url        String url = "jdbc:mysql://localhost:3306/jdbcstudy?serverTimezone=UTC";        String username = "root";        String password = "root";        //3,连接成功,返回数据库对象    Connection代表数据库        Connection connection = DriverManager.getConnection(url, username, password);        //4.执行SQL的对象Statement 执行sql的对象        Statement statement = connection.createStatement();        //5.执行SQL的对象  去  执行SQL,可能存在结果,查看返回结果        String sql = "select * from users";        ResultSet resultSet = statement.executeQuery(sql);//返回的结果集,结果集中封装了我们全部的查询出来的结果        //        statement.executeUpdate();//更新,插入,删除都用这个		//        statement.executeBatch();//批处理		//        statement.execute();//执行任何SQL                        //        resultSet.beforeFirst();//移动到最前面		//        resultSet.afterLast();//移动到最后面		//        resultSet.next();//移动到下一个        while (resultSet.next()){            System.out.println("id="+resultSet.getObject("id"));            System.out.println("name="+resultSet.getObject("name"));            System.out.println("pwd="+resultSet.getObject("password"));            System.out.println("email="+resultSet.getObject("email"));            System.out.println("birth="+resultSet.getObject("birthday"));            System.out.println("===================================================");        }        //6.释放连接        resultSet.close();        statement.close();        connection.close();    }}
```



## statement对象

JDBC中的statement对象用于向数据库发送SQL语句,像完成对数据库的增删改查,只需要通过这个对象向数据库发送增删改查语句即可

Statement对象的executeUpdate方法,用于向数据库发送增删改的SQL语句,executeUpdate执行完后,将会返回一个整数

Statement.executeQuery方法用于向数据库发送查询语句,executeQuery方法返回代表查询结果的ResultSet对象



>CRUD操作-create

使用executeUpdate(String sql)方法完成数据库添加操作

```java
Statement st = conn.createStatement();String sql = "insert into user(...)values(...)";int num = st.executeUpdate(sql);if(num>0){    System.out.println("插入成功!");}
```



>CRUD操作-delete

使用executeUpdate(String sql)方法完成数据库删除操作

```java
Statement st = conn.createStatement();String sql = "delete from user where id=1";int num = st.executeUpdate(sql);if(num>0){    System.out.println("删除成功!");}
```



>CRUD操作-update

使用executeUpdate(String sql)方法完成数据库修改操作

```java
Statement st = conn.createStatement();String sql = "update user set name='' where ";int num = st.executeUpdate(sql);if(num>0){    System.out.println("删除成功!");}
```



>CRUD操作-select

使用executeUpdate(String sql)方法完成数据库查询操作

```java
Statement st = conn.createStatement();String sql = "select * from user where id=1";ResultSet rs = st.executeQuery(sql);while(rs.next()){    //根据获取列的数据类型,分别调用rs的相应方法映射到Java对象中}
```



## JDBC工具类封装JDBC

>src目录下创建一个file-->db.properties并添加以下内容

```java
driver=com.mysql.cj.jdbc.Driverurl=jdbc:mysql://localhost:3306/jdbcstudy?serverTimezone=UTCusername=rootpassword=root
```

>创建JdbcUtils类封装jdbc

```java
package Demo14.JDBC;import java.io.IOException;import java.io.InputStream;import java.sql.*;import java.util.Properties;//JDBC工具类:封装JDBCpublic class JdbcUtils {    private static String driver = null;    private static String url = null;    private static String username = null;    private static String password = null;    static {        try {            InputStream in = JdbcUtils.class.getClassLoader().getResourceAsStream("db.properties");            Properties properties = new Properties();            properties.load(in);            driver = properties.getProperty("driver");            url = properties.getProperty("url");            username = properties.getProperty("username");            password = properties.getProperty("password");            //1.驱动只用加载一次            Class.forName(driver);        } catch (IOException | ClassNotFoundException e) {            e.printStackTrace();        }    }    //2.获取连接    public static Connection getConnection() throws SQLException {        return DriverManager.getConnection(url, username, password);    }    //3.释放连接资源    public static void release(Connection conn, Statement st, ResultSet rs) {        if (rs != null) {            try {                rs.close();            } catch (SQLException e) {                e.printStackTrace();            }        }        if (st != null) {            try {                st.close();            } catch (SQLException e) {                e.printStackTrace();            }        }        if (conn != null) {            try {                conn.close();            } catch (SQLException e) {                e.printStackTrace();            }        }    }}
```

>创建一个测试类,编写增删改的方法

```java
package Demo14.JDBC;import java.sql.Connection;import java.sql.ResultSet;import java.sql.SQLException;import java.sql.Statement;//测试public class Test {    public static void main(String[] args) {        Connection conn = null;        Statement st = null;        ResultSet rs = null;        try {            conn = JdbcUtils.getConnection();//调用JDBC工具类来获取数据库连接            st = conn.createStatement();//获得SQL的执行对象//            String sql = "insert into users(id,name,password,email,birthday)" +//                    "values(4,'luyuning',123456,'1120864780@qq.com','1998-11-20')";//增//            String sql = "delete from users where id = 4";//删            String sql = "update users set name = 'luyuning',email = '1120864780@qq.com' where id=2";//改            int i = st.executeUpdate(sql);            if (i > 0) {//                System.out.println("插入成功!");//                System.out.println("删除成功!");                System.out.println("更新成功!");            }        } catch (SQLException e) {            e.printStackTrace();        } finally {            JdbcUtils.release(conn, st, rs);        }    }}
```

>创建一个测试类,编写查询的方法

```java
package Demo14.JDBC;import java.sql.Connection;import java.sql.ResultSet;import java.sql.SQLException;import java.sql.Statement;public class TestSelect {    public static void main(String[] args) {        Connection conn = null;        Statement st = null;        ResultSet rs = null;        try {            conn = JdbcUtils.getConnection();            st = conn.createStatement();            //SQL            String sql = "select * from users";            rs = st.executeQuery(sql);//查询完毕会返回一个结果            while (rs.next()){                System.out.println(rs.getString("name"));            }        } catch (SQLException e) {            e.printStackTrace();        }        if (conn != null) {            try {                conn.close();            } catch (SQLException e) {                e.printStackTrace();            }        }        if (st != null) {            try {                st.close();            } catch (SQLException e) {                e.printStackTrace();            }        }        if (rs != null) {            try {                rs.close();            } catch (SQLException e) {                e.printStackTrace();            }        }    }}
```



## PreParedStatement对象

SQL注入:sql存在漏洞,会被攻击导致数据泄露(`SQL会被拼接 or`)

==PreParedStatement可以防止SQL注入的问题,且效率更高!==



>创建一个测试类,编写防SQL注入的增删改的方法

```java
package Demo14.JDBC;import java.sql.Connection;import java.sql.PreparedStatement;import java.sql.SQLException;//测试--防SQL注入public class Test02 {    public static void main(String[] args) {        Connection conn = null;        PreparedStatement st = null;//防SQL注入        try {            conn = JdbcUtils.getConnection();            //Statement和PreparedStatement的区别            //1.使用?占位符代替参数//            String sql = "insert into users(id,name,password,email,birthday)values(?,?,?,?,?)";//增//            String sql = "delete from users where id = ?";//删            String sql = "update users set name = ? where id = ?";//改            st = conn.prepareStatement(sql);//预编译SQL,先些SQL,然后不执行            //2.手动给参数赋值            //******增********//            st.setInt(1, 4);//给第一个?赋值//            st.setString(2, "aaa");//给第二个?赋值//            st.setString(3, "123456");//给第三个?赋值//            st.setString(4, "123456@qq.com");//给第四个?赋值//            st.setDate(5, new java.sql.Date(new Date().getTime()));//给第五个?赋值            //******删********//            st.setInt(1,4);            //******改********            st.setString(1, "luyuningning");            st.setInt(2, 2);            //执行            int i = st.executeUpdate();            if (i > 0) {//                System.out.println("插入成功!");//                System.out.println("删除成功!");                System.out.println("修改成功!");            }        } catch (SQLException e) {            e.printStackTrace();        } finally {            JdbcUtils.release(conn, st, null);        }    }}
```

>创建一个测试类,编写防SQL注入的查询的方法

```java
package Demo14.JDBC;import java.sql.Connection;import java.sql.PreparedStatement;import java.sql.ResultSet;import java.sql.SQLException;//防SQL注入--selectpublic class TestSelect02 {    public static void main(String[] args) {        Connection conn = null;        PreparedStatement st = null;        ResultSet rs = null;        try {             conn = JdbcUtils.getConnection();             String sql = "select * from users where id = ?";             st = conn.prepareStatement(sql);             st.setInt(1,2);             //执行            rs = st.executeQuery();            if (rs.next()){                System.out.println(rs.getString("name"));            }        } catch (SQLException e) {            e.printStackTrace();        }finally {            JdbcUtils.release(conn,st,rs);        }    }}
```



## 使用IDEA连接数据库

<img src="E:\Typora\Typora图片\image-20210426211905162.png" alt="image-20210426211905162" style="zoom:80%;" />![image-20210426212214724](E:\Typora\Typora图片\image-20210426212214724.png)

![image-20210426212257423](E:\Typora\Typora图片\image-20210426212257423.png)

>写SQL的窗口

![image-20210426212548865](E:\Typora\Typora图片\image-20210426212548865.png)



## 事务

> 代码实现

1.开启事务 conn.setAutoCommit(false);

2.一组业务执行完毕,提交事务

3.可以在catch语句中显示的定义回滚语句,但默认失败就会回滚

```java
package Demo14.JDBC;

import java.sql.Connection;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;

public class TestTransation01 {
    public static void main(String[] args) {
        Connection conn = null;
        PreparedStatement st = null;
        ResultSet rs = null;

        try {
            conn = JdbcUtils.getConnection();
            //关闭数据库的自动提交后会自动开启事务
            conn.setAutoCommit(false);
            String sql1 = "update account set money = money-100 where name = 'A'";
            st = conn.prepareStatement(sql1);
            st.executeUpdate();

            String sql2 = "update account set money = money +100 where name = 'B'";
            st = conn.prepareStatement(sql2);
            st.executeUpdate();

            //业务完毕,提交事务
            conn.commit();
            System.out.println("成功!");


        } catch (SQLException e) {
            try {
                conn.rollback();//如果失败则回滚事务
            } catch (SQLException throwables) {
                throwables.printStackTrace();
            }
            e.printStackTrace();
        } finally {
            JdbcUtils.release(conn, st, rs);
        }
    }
}
```



## 数据库连接池

**池化技术:准备一些预先的资源,过来就连接预先准备好的系统资源**

编写连接池:实现一个接口DataSource



>开源数据源实现

DBCP

C3P0

Druid:阿里巴巴

使用了数据库连接池之后,在项目开发中就不需要编写连接数据库的代码了!
